#!/usr/bin/env perl
use strict;
use warnings;
use PPI;

# operator “strength” ranking
my %rank = (
  '>'  => 3, '>=' => 2,
  '==' => 1, 'eq' => 1,
  '<=' => 2, '<'  => 3,
);

sub parse_cond {
  my $str = shift;
  $str =~ s/^\s*\(//;  $str =~ s/\)\s*$//;
  if ($str =~ /^\s*\$(\w+)\s*(>=|>|==|<=|<|eq|ne)\s*(.+?)\s*$/) {
    return ($1, $2, $3);
  }
  if ($str =~ /^\s*(.+?)\s*(>=|>|==|<=|<|eq|ne)\s*\$(\w+)\s*$/) {
    my ($val, $op, $var) = ($1, $2, $3);
    my %flip = ('<' => '>', '<=' => '>=', '>' => '<',
                '>=' => '<=', '==' => '==', 'eq' => 'eq', 'ne' => 'ne');
    return ($var, $flip{$op}, $val);
  }
  return;
}

die "Usage: $0 file1.pl [file2.pl ...]\n" unless @ARGV;

for my $file (@ARGV) {
  print "\nScanning $file …\n";
  my $doc = PPI::Document->new($file)
    or warn "  ✗ Failed to parse $file: $@\n" and next;

  my $ifs = $doc->find('PPI::Structure::If') || [];
  for my $outer (@$ifs) {
    my $c1 = $outer->schild(0)->content;
    my ($v1,$o1,$x1) = parse_cond($c1) or next;

    for my $inner (@$ifs) {
      next if $inner == $outer;
      # only scan direct children
      next unless $inner->parent == $outer->block;
      
      my $c2 = $inner->schild(0)->content;
      my ($v2,$o2,$x2) = parse_cond($c2) or next;
      next unless $v1 eq $v2;

      # 1) numeric‐threshold redundancy
      if (exists $rank{$o1} && exists $rank{$o2}) {
        if ($rank{$o1} == $rank{$o2} && $o1 =~ /[><]/ && $x2 <= $x1
         || $rank{$o1} <  $rank{$o2}
            && (
               ($o1 =~ />=?/ && $x2 <= $x1)
            || ($o1 =~ /<=?/ && $x2 >= $x1)
               )
        ) {
          printf "  [%s:%d] redundant “%s” under “%s”\n",
                 $file, $inner->start->location->[0], $c2, $c1;
          next;
        }
      }

      # 2) identical unless‐unless
      if ($outer->schild(0)->content eq 'unless'
       && $inner->schild(0)->content eq 'unless'
       && $c1 eq $c2)
      {
        printf "  [%s:%d] nested identical %s\n",
               $file, $inner->start->location->[0], "unless($c2)";
        next;
      }

      # 3) exact‐text duplicate
      if ($c1 eq $c2) {
        printf "  [%s:%d] duplicate test “%s”\n",
               $file, $inner->start->location->[0], $c2;
        next;
      }

      # 4) duplicate regex‐match
      if ($c1 =~ /\Q\$$v1 =~\E\s*(.+)$/ && $c2 =~ /\Q\$$v1 =~\E\s*\1/) {
        printf "  [%s:%d] duplicate regex match %s\n",
               $file, $inner->start->location->[0], $1;
        next;
      }
    }
  }
}

