#!/usr/bin/env perl
use strict;
use warnings;
use PPI;

# “Strength” ranking for nested‐numeric logic (still used below)
my %rank = (
  '>'  => 3, '>=' => 2,
  '==' => 1, 'eq' => 1,
  '<=' => 2, '<'  => 3,
);

sub parse_cond {
  my $str = shift;
  $str =~ s/^\s*\(//;  $str =~ s/\)\s*$//;
  # $var OP val
  if ($str =~ /^\s*\$(\w+)\s*(>=|>|==|<=|<|eq|ne)\s*(.+?)\s*$/) {
    return ($1, $2, $3);
  }
  # val OP $var  → flip
  if ($str =~ /^\s*(.+?)\s*(>=|>|==|<=|<|eq|ne)\s*\$(\w+)\s*$/) {
    my ($val,$op,$var) = ($1,$2,$3);
    my %flip = ('<' => '>', '<=' => '>=',
                '>' => '<', '>=' => '<=',
                '==' => '==','eq'=>'eq','ne'=>'ne');
    return ($var, $flip{$op}, $val);
  }
  return;  # not a simple scalar comparison
}

die "Usage: $0 file1.pl [file2.pl ...]\n" unless @ARGV;
for my $file (@ARGV) {
  print "\nScanning $file …\n";
  my $doc = PPI::Document->new($file)
    or warn "  ✗ parse failed: $@\n" and next;

  # grab all compound statements (if/elsif/unless/while/until)
  my $cmps = $doc->find('PPI::Statement::Compound') || [];

  for my $outer (@$cmps) {
    my $type1 = $outer->type;  # e.g. 'if','elsif','while','until','unless'
    next unless $type1 =~ /^(if|elsif|while|until|unless)$/;

    my $cond1 = $outer->schild(1)->content;    # the “(...)”
    my ($v1,$o1,$x1) = parse_cond($cond1) || ();

    # Heuristic #5: boolean‐AND redundancies (existing)
    if ($cond1 =~ /&&/) {
      my @parts = map { s/^\s+|\s+$//gr } split /&&/, $cond1;
      for my $p (@parts) {
        next unless $p =~ /^\$(\w+)$/;
        for my $q (@parts) {
          next if $p eq $q;
          my ($v2,$o2,$x2) = parse_cond($q) or next;
          if ($1 eq $v2 && exists $rank{$o2}) {
            printf "  [%s:%d] “%s” redundant in AND with “%s”\n",
              $file, $outer->start->location->[0], $p, $q;
          }
        }
      }
    }

    # Heuristic #6: boolean‐OR redundancies (new)
    if ($cond1 =~ /\|\|/) {
      my @parts = map { s/^\s+|\s+$//gr } split /\|\|/, $cond1;
      for my $i (0 .. $#parts) {
        for my $j ($i+1 .. $#parts) {
          my ($p,$q) = ($parts[$i], $parts[$j]);
          my ($v2,$o2,$x2) = parse_cond($q) or next;
          my ($v3,$o3,$x3) = parse_cond($p) or next;
          next unless $v2 eq $v3;

          # both “>”‐style: q implies p if x2 >= x3
          if (($o3 eq '>'||$o3 eq '>=') && ($o2 eq '>'||$o2 eq '>=')
              && $x2 >= $x3)
          {
            printf "  [%s:%d] “%s” redundant in OR with “%s”\n",
              $file, $outer->start->location->[0], $q, $p;
            next;
          }

          # both “<”‐style: q implies p if x2 <= x3
          if (($o3 eq '<'||$o3 eq '<=') && ($o2 eq '<'||$o2 eq '<=')
              && $x2 <= $x3)
          {
            printf "  [%s:%d] “%s” redundant in OR with “%s”\n",
              $file, $outer->start->location->[0], $q, $p;
            next;
          }
        }
      }
    }

    # …then your nested‐block checks exactly as before…
    for my $inner (@$cmps) {
      next if $inner == $outer;
      next unless $inner->parent && $inner->parent == $outer->schild(2);
      my $type2 = $inner->type;
      next unless $type2 =~ /^(if|elsif|while|until|unless)$/;
      my $cond2 = $inner->schild(1)->content;
      my ($v2,$o2,$x2) = parse_cond($cond2) or next;
      next unless defined $v1 && $v1 eq $v2;

      # numeric‐threshold, identical, regex… same as before
      if (exists $rank{$o1} && exists $rank{$o2}) {
        if ( $rank{$o1} == $rank{$o2} && $o1 =~ /[><]/ && $x2 <= $x1
          || $rank{$o1} < $rank{$o2}
             && (
                ($o1 =~ />=?/ && $x2 <= $x1)
             || ($o1 =~ /<=?/ && $x2 >= $x1)
                )
        ) {
          printf "  [%s:%d] redundant “%s” under “%s”\n",
                 $file, $inner->start->location->[0], $cond2, $cond1;
          next;
        }
      }
      if ($type1 eq $type2 && $cond1 eq $cond2) {
        printf "  [%s:%d] nested identical %s(%s)\n",
               $file, $inner->start->location->[0], $type2, $cond2;
        next;
      }
      if ($cond1 eq $cond2) {
        printf "  [%s:%d] duplicate test “%s”\n",
               $file, $inner->start->location->[0], $cond2;
        next;
      }
      if ($cond1 =~ /\Q\$$v1 =~\E\s*(.+)$/ && $cond2 =~ /\Q\$$v1 =~\E\s*\1/) {
        printf "  [%s:%d] duplicate regex match %s\n",
               $file, $inner->start->location->[0], $1;
        next;
      }
    }
  }
}
