#!/usr/bin/env perl
use strict;
use warnings;
use PPI;

# operator‐strength ranking
my %rank = (
  '>'  => 3, '>=' => 2,
  '==' => 1, 'eq' => 1,
  '<=' => 2, '<'  => 3,
);

sub parse_cond {
  my $s = shift;
  $s =~ s/^\s*\(//;  $s =~ s/\)\s*$//;
  if ($s =~ /^\s*\$(\w+)\s*(>=|>|==|<=|<|eq|ne)\s*(.+?)\s*$/) {
    return ($1, $2, $3);
  }
  if ($s =~ /^\s*(.+?)\s*(>=|>|==|<=|<|eq|ne)\s*\$(\w+)\s*$/) {
    my ($val,$op,$var) = ($1,$2,$3);
    my %flip = ('<' => '>', '<=' => '>=',
                '>' => '<', '>=' => '<=',
                '==' => '==','eq'=>'eq','ne'=>'ne');
    return ($var, $flip{$op}, $val);
  }
  return;
}

die "Usage: $0 file1.pl [file2.pl ...]\n" unless @ARGV;
for my $file (@ARGV) {
  print "\nScanning $file …\n";
  my $doc = PPI::Document->new($file)
    or warn "  ✗ parse failed: $@\n" and next;

  my $cmps = $doc->find('PPI::Statement::Compound') || [];
  for my $outer (@$cmps) {
    my $type1 = $outer->type;
    next unless $type1 =~ /^(if|elsif|unless|while|until)$/;
    my $cond1 = $outer->schild(1)->content;
    my ($v1,$o1,$x1) = parse_cond($cond1) || ();

    # … boolean‐AND and OR checks as before …
    # (omitted here for brevity; keep your existing AND/OR logic)

    # nested‐block checks
    my $block = $outer->schild(2);
    next unless $block and $block->isa('PPI::Structure::Block');

    my $inner_cmps = $block->find('PPI::Statement::Compound') || [];
    for my $inner (@$inner_cmps) {
      my $type2 = $inner->type;
      next unless $type2 =~ /^(if|elsif|unless|while|until)$/;
      my $cond2 = $inner->schild(1)->content;
      my ($v2,$o2,$x2) = parse_cond($cond2) or next;
      next unless defined $v1 && $v1 eq $v2;

      # numeric‐threshold redundancy
      if (exists $rank{$o1} && exists $rank{$o2}) {
        if ( $rank{$o1} == $rank{$o2} && $o1 =~ /[><]/ && $x2 <= $x1
          || $rank{$o1} < $rank{$o2}
             && (
                ($o1 =~ />=?/ && $x2 <= $x1)
             || ($o1 =~ /<=?/ && $x2 >= $x1)
                )
        ) {
          printf "  [%s:%d] redundant “%s” under “%s”\n",
                 $file, $inner->line_number, $cond2, $cond1;
          next;
        }
      }

      # identical/duplicate tests
      if ($type1 eq $type2 && $cond1 eq $cond2) {
        printf "  [%s:%d] nested identical %s(%s)\n",
               $file, $inner->line_number, $type2, $cond2;
        next;
      }
      if ($cond1 eq $cond2) {
        printf "  [%s:%d] duplicate test “%s”\n",
               $file, $inner->line_number, $cond2;
        next;
      }

      # duplicate regex‐match
      if ($cond1 =~ /\Q\$$v1 =~\E\s*(.+)$/ && $cond2 =~ /\Q\$$v1 =~\E\s*\1/) {
        printf "  [%s:%d] duplicate regex match %s\n",
               $file, $inner->line_number, $1;
      }
    }
  }
}
