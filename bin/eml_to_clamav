#!/usr/bin/env perl

use strict;
use warnings;

use MIME::Parser;
use Digest::MD5 qw(md5_hex);
use Digest::SHA qw(sha1_hex sha256_hex);
use File::Temp qw(tempdir);
use File::Basename;
use File::Find;
use File::Path qw(make_path);
use Getopt::Long;
use Pod::Usage;
use Time::HiRes qw(time);
use Encode qw(decode);
use JSON::PP;
use XML::Simple;
use URI::Find;
use LWP::UserAgent;
use DBI;
use threads;
use Thread::Queue;
use HTTP::Daemon;
use HTTP::Status;
use Digest::SHA qw(sha256_hex);
use Net::DNS;

# Try to load optional modules
my $HAS_SSDEEP = eval { require Digest::ssdeep; 1; };
my $HAS_VIRUSTOTAL = eval { require WebService::VirusTotal; 1; };

# Global variables
my $output_file = 'signatures.hdb';
my $sig_prefix = 'NJH';
my $help = 0;
my $verbose = 0;
my $recursive = 0;
my $min_size = 10;
my $max_size = 50 * 1024 * 1024;
my $duplicate_check = 1;
my $yara_output = '';
my $include_body = 0;
my $threads = 1;
my $json_output = '';
my $xml_output = '';
my $template_dir = '';
my $extract_iocs = 0;
my $use_fuzzy = 0;
my $virustotal_key = '';
my $database_file = '';
my $api_port = 0;
my $api_host = 'localhost';

# Custom signature templates
my %templates = (
	'banking_trojan' => {
		'patterns' => [
			'bank', 'account', 'verify', 'suspended', 'click here'
		],
		'weight' => 0.8
	},
	'ransomware' => {
		'patterns' => [
			'encrypted', 'decrypt', 'payment', 'bitcoin', 'files locked'
		],
		'weight' => 0.9
	},
	'credential_phish' => {
		'patterns' => [
			'login', 'password', 'expired', 'verify account', 'update payment'
		],
		'weight' => 0.7
	}
);

# Parse command line options
GetOptions(
	'output|o=s'		 => \$output_file,
	'prefix|p=s'		 => \$sig_prefix,
	'verbose|v+'		 => \$verbose,
	'recursive|r'		=> \$recursive,
	'min-size=i'		 => \$min_size,
	'max-size=i'		 => \$max_size,
	'no-duplicate-check' => sub { $duplicate_check = 0 },
	'yara=s'			 => \$yara_output,
	'include-body'	   => \$include_body,
	'threads|j=i'		=> \$threads,
	'json=s'			 => \$json_output,
	'xml=s'			  => \$xml_output,
	'templates=s'		=> \$template_dir,
	'extract-iocs'	   => \$extract_iocs,
	'fuzzy-hash'		 => \$use_fuzzy,
	'virustotal-key=s'   => \$virustotal_key,
	'database=s'		 => \$database_file,
	'api-port=i'		 => \$api_port,
	'api-host=s'		 => \$api_host,
	'help|h'			 => \$help,
) or pod2usage(2);

pod2usage(1) if $help;

# Start API server if requested
if ($api_port > 0) {
	start_api_server();
	exit(0);
}

pod2usage('Error: No EML files specified') if(@ARGV == 0);

my @input_paths = @ARGV;
my @eml_files;

# Load custom templates if specified
load_custom_templates($template_dir) if $template_dir;

# Initialize database if specified
my $dbh;
if ($database_file) {
	$dbh = init_database($database_file);
}

# Initialize VirusTotal client
my $vt_client;
if ($virustotal_key && $HAS_VIRUSTOTAL) {
	$vt_client = WebService::VirusTotal->new(api_key => $virustotal_key);
	print "VirusTotal integration enabled\n" if $verbose;
}

# Collect EML files
foreach my $path (@input_paths) {
	if (-f $path) {
		push @eml_files, $path;
	} elsif (-d $path && $recursive) {
		find(sub {
			push @eml_files, $File::Find::name if /\.eml$/i && -f;
		}, $path);
	} elsif (-d $path) {
		warn "Skipping directory '$path' (use -r for recursive)\n";
	} else {
		warn "Path '$path' does not exist\n";
	}
}

die 'Error: No EML files found' unless @eml_files;

print 'Found ', scalar(@eml_files), " EML file(s)\n" if $verbose;

# Filter by size and validate
my @valid_files;
foreach my $file (@eml_files) {
	my $size = -s $file;
	if ($size < $min_size) {
		print "Skipping $file (too small: $size bytes)\n" if $verbose >= 2;
		next;
	}
	if ($size > $max_size) {
		print "Skipping $file (too large: $size bytes)\n" if $verbose >= 2;
		next;
	}
	push @valid_files, $file;
}

@eml_files = @valid_files;
print "Processing ", scalar(@eml_files), " valid EML file(s)\n" if $verbose;

# Initialize data structures
my %seen_hashes if $duplicate_check;
my @results;
my %global_iocs = (
	urls => {},
	ips => {},
	domains => {},
	emails => {}
);

# Statistics
my %stats = (
	files_processed => 0,
	files_failed => 0,
	signatures_generated => 0,
	attachments_processed => 0,
	duplicates_skipped => 0,
	iocs_extracted => 0,
	vt_queries => 0,
	start_time => time(),
);

# Multi-threading setup
if ($threads > 1) {
	process_files_threaded(\@eml_files);
} else {
	process_files_single(\@eml_files);
}

# Generate outputs
generate_all_outputs(\@results);

# Print final statistics
print_final_stats();

# Close database
$dbh->disconnect if $dbh;

###################
# CORE FUNCTIONS
###################

sub process_files_single {
	my ($files) = @_;

	# Open output files
	open(my $sig_fh, '>>', $output_file) or die "Cannot open $output_file: $!";
	my $yara_fh;
	if ($yara_output) {
		open($yara_fh, '>>', $yara_output) or die "Cannot open $yara_output: $!";
		write_yara_header($yara_fh);
	}

	my $file_count = 0;
	foreach my $eml_file (@$files) {
		$file_count++;
		print "\n", "="x60, "\n" if $verbose;
		print "[$file_count/", scalar(@$files), "] Processing: ", basename($eml_file), "\n" if $verbose;

		my $result = eval {
			process_eml_file($eml_file, $sig_fh, $yara_fh);
		};

		if ($@) {
			warn "Error processing '$eml_file': $@\n";
			$stats{files_failed}++;
			$result = create_error_result($eml_file, $@);
		} else {
			$stats{files_processed}++;
		}

		push @results, $result if $result;

		# Store in database if configured
		store_result_in_db($dbh, $result) if $dbh && $result;

		if ($file_count % 100 == 0 && !$verbose) {
			print "Processed $file_count/", scalar(@$files), " files...\n";
		}
	}

	close($sig_fh);
	close($yara_fh) if $yara_fh;
}

sub process_files_threaded {
	my ($files) = @_;

	my $work_queue = Thread::Queue->new();
	my $result_queue = Thread::Queue->new();

	# Add work items
	$work_queue->enqueue($_) for @$files;
	$work_queue->end();

	# Create worker threads
	my @workers;
	for my $i (1..$threads) {
		push @workers, threads->create(\&worker_thread, $work_queue, $result_queue, $i);
	}

	# Collect results
	my $processed = 0;
	my $total = scalar(@$files);

	while ($processed < $total) {
		my $result = $result_queue->dequeue();
		push @results, $result if $result;
		$processed++;

		if ($processed % 100 == 0 && !$verbose) {
			print "Processed $processed/$total files...\n";
		}
	}

	# Wait for all threads to complete
	$_->join() for @workers;

	# Aggregate signatures from thread-local files
	aggregate_thread_outputs();
}

sub worker_thread {
	my ($work_queue, $result_queue, $thread_id) = @_;

	# Thread-local output files
	my $thread_sig_file = "${output_file}.thread_${thread_id}";
	my $thread_yara_file = $yara_output ? "${yara_output}.thread_${thread_id}" : '';

	open(my $sig_fh, '>>', $thread_sig_file) or die "Cannot open $thread_sig_file: $!";
	my $yara_fh;
	if ($thread_yara_file) {
		open($yara_fh, '>>', $thread_yara_file) or die "Cannot open $thread_yara_file: $!";
		write_yara_header($yara_fh);
	}

	while (defined(my $eml_file = $work_queue->dequeue())) {
		my $result = eval {
			process_eml_file($eml_file, $sig_fh, $yara_fh);
		};

		if ($@) {
			warn "Thread $thread_id: Error processing '$eml_file': $@\n";
			$result = create_error_result($eml_file, $@);
			lock($stats{files_failed});
			$stats{files_failed}++;
		} else {
			lock($stats{files_processed});
			$stats{files_processed}++;
		}

		$result_queue->enqueue($result);
	}

	close($sig_fh);
	close($yara_fh) if $yara_fh;
}

sub process_eml_file {
	my ($eml_file, $sig_fh, $yara_fh) = @_;

	my $temp_dir = tempdir(CLEANUP => 1);
	my $parser = MIME::Parser->new();
	$parser->output_dir($temp_dir);
	$parser->extract_nested_messages(1);
	$parser->extract_uuencode(1);
	$parser->decode_headers(1);
	$parser->filer->ignore_filename(1);

	my $entity = $parser->parse_open($eml_file);
	my $file_basename = basename($eml_file, '.eml');
	$file_basename =~ s/[^a-zA-Z0-9._-]/_/g;

	# Initialize result structure
	my $result = {
		filename => $eml_file,
		basename => $file_basename,
		timestamp => time(),
		size => -s $eml_file,
		signatures => [],
		attachments => [],
		iocs => { urls => [], ips => [], domains => [], emails => [] },
		fuzzy_hash => '',
		virustotal => {},
		template_matches => [],
		yara_rules => []
	};

	# Generate fuzzy hash if enabled
	if ($use_fuzzy && $HAS_SSDEEP) {
		$result->{fuzzy_hash} = Digest::ssdeep::hash_file($eml_file);
	}

	# Process email headers and body
	process_email_content($entity, $result, $sig_fh, $yara_fh);

	# Process attachments
	process_attachments($entity, $result, $sig_fh, $yara_fh, $file_basename);

	# Extract IOCs if enabled
	extract_iocs_from_email($entity, $result) if $extract_iocs;

	# Check templates
	check_template_matches($entity, $result);

	# Query VirusTotal if enabled
	query_virustotal($result) if $vt_client;

	$entity->purge;
	return $result;
}

sub process_email_content {
	my ($entity, $result, $sig_fh, $yara_fh) = @_;

	my $head = $entity->head;
	my $subject = decode_header($head->get('Subject', 0) || '');
	my $from = decode_header($head->get('From', 0) || '');
	my $to = decode_header($head->get('To', 0) || '');
	my $message_id = $head->get('Message-ID', 0) || '';

	chomp($subject, $from, $to, $message_id);

	my $sig_data = "Subject: $subject\nFrom: $from\nTo: $to\nMessage-ID: $message_id";

	if ($include_body) {
		my $body = get_email_body($entity);
		$sig_data .= "\nBody: " . substr($body, 0, 1000) if $body;
	}

	# Generate signatures
	my $sigs = generate_signatures($sig_data, $result->{basename} . "_EMAIL_HEADERS");
	push @{$result->{signatures}}, @$sigs;
	write_signatures_to_file($sigs, $sig_fh);

	# Generate YARA rules
	if ($yara_fh) {
		my $yara_rule = generate_yara_email_rule($subject, $from, $to, $result->{basename});
		print $yara_fh $yara_rule if $yara_rule;
		push @{$result->{yara_rules}}, $yara_rule if $yara_rule;
	}
}

sub process_attachments {
	my ($entity, $result, $sig_fh, $yara_fh, $file_basename) = @_;

	my @parts = $entity->parts_DFS;
	my $attachment_count = 0;

	foreach my $part (@parts) {
		next if is_text_part($part);

		my $filename = get_attachment_filename($part);
		my $data = extract_attachment_data($part);

		next unless defined $data && length($data) >= $min_size;
		next if length($data) > $max_size;

		# Check for duplicates
		if ($duplicate_check) {
			my $quick_hash = md5_hex(substr($data, 0, 1024));
			if ($seen_hashes{$quick_hash}) {
				$stats{duplicates_skipped}++;
				next;
			}
			$seen_hashes{$quick_hash} = 1;
		}

		$filename =~ s/[^a-zA-Z0-9._-]/_/g;
		$filename = "ATTACHMENT_${attachment_count}" if !$filename || $filename eq '';

		# Create attachment result
		my $att_result = {
			filename => $filename,
			size => length($data),
			content_type => $part->effective_type,
			is_executable => is_executable($data, $filename),
			signatures => [],
			fuzzy_hash => '',
			virustotal => {}
		};

		# Generate signatures
		my $sigs = generate_signatures($data, "${file_basename}_${filename}");
		push @{$att_result->{signatures}}, @$sigs;
		write_signatures_to_file($sigs, $sig_fh);

		# Fuzzy hash for attachment
		if ($use_fuzzy && $HAS_SSDEEP) {
			$att_result->{fuzzy_hash} = Digest::ssdeep::hash($data);
		}

		# YARA rules for executables
		if ($yara_fh && $att_result->{is_executable}) {
			my $yara_rule = generate_yara_executable_rule($data, $filename, $file_basename);
			print $yara_fh $yara_rule if $yara_rule;
			push @{$result->{yara_rules}}, $yara_rule if $yara_rule;
		}

		# VirusTotal check for attachment
		if ($vt_client) {
			query_virustotal_attachment($att_result, $data);
		}

		push @{$result->{attachments}}, $att_result;
		$attachment_count++;
		$stats{attachments_processed}++;
	}
}

sub extract_iocs_from_email {
	my ($entity, $result) = @_;

	my $content = get_full_email_content($entity);

	# Extract URLs
	my $finder = URI::Find->new(sub {
		my ($url) = @_;
		push @{$result->{iocs}->{urls}}, $url;
		$global_iocs{urls}->{$url}++;
		return $url;
	});
	$finder->find(\$content);

	# Extract IP addresses
	while ($content =~ /\b(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\b/g) {
		my $ip = $1;
		next unless is_valid_ip($ip);
		push @{$result->{iocs}->{ips}}, $ip;
		$global_iocs{ips}->{$ip}++;
	}

	# Extract email addresses
	while ($content =~ /\b([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})\b/g) {
		my $email = $1;
		push @{$result->{iocs}->{emails}}, $email;
		$global_iocs{emails}->{$email}++;
	}

	# Extract domains from URLs and emails
	foreach my $url (@{$result->{iocs}->{urls}}) {
		if ($url =~ m{https?://([^/]+)}) {
			my $domain = $1;
			$domain =~ s/:\d+$//; # Remove port
			push @{$result->{iocs}->{domains}}, $domain;
			$global_iocs{domains}->{$domain}++;
		}
	}

	foreach my $email (@{$result->{iocs}->{emails}}) {
		if ($email =~ /@(.+)$/) {
			my $domain = $1;
			push @{$result->{iocs}->{domains}}, $domain;
			$global_iocs{domains}->{$domain}++;
		}
	}

	my $total_iocs = @{$result->{iocs}->{urls}} + @{$result->{iocs}->{ips}} +
					 @{$result->{iocs}->{domains}} + @{$result->{iocs}->{emails}};
	$stats{iocs_extracted} += $total_iocs;
}

sub check_template_matches {
	my ($entity, $result) = @_;

	my $content = lc(get_full_email_content($entity));

	foreach my $template_name (keys %templates) {
		my $template = $templates{$template_name};
		my $matches = 0;
		my $total_patterns = @{$template->{patterns}};

		foreach my $pattern (@{$template->{patterns}}) {
			$matches++ if $content =~ /\Q$pattern\E/;
		}

		my $match_ratio = $matches / $total_patterns;
		if ($match_ratio >= $template->{weight}) {
			push @{$result->{template_matches}}, {
				name => $template_name,
				score => $match_ratio,
				matches => $matches,
				total => $total_patterns
			};
		}
	}
}

sub query_virustotal {
	my ($result) = @_;

	return unless $vt_client;

	# Check main email file hash
	if ($result->{signatures} && @{$result->{signatures}}) {
		my $hash = $result->{signatures}->[0]->{sha256}; # Use first SHA256
		eval {
			my $response = $vt_client->file_report($hash);
			$result->{virustotal} = {
				scans => $response->{scans} || {},
				positives => $response->{positives} || 0,
				total => $response->{total} || 0,
				scan_date => $response->{scan_date} || ''
			};
			$stats{vt_queries}++;
		};
		warn "VirusTotal query error: $@" if $@;
	}
}

sub query_virustotal_attachment {
	my ($att_result, $data) = @_;

	return unless $vt_client;

	my $hash = sha256_hex($data);
	eval {
		my $response = $vt_client->file_report($hash);
		$att_result->{virustotal} = {
			scans => $response->{scans} || {},
			positives => $response->{positives} || 0,
			total => $response->{total} || 0,
			scan_date => $response->{scan_date} || ''
		};
		$stats{vt_queries}++;
	};
	warn "VirusTotal attachment query error: $@" if $@;
}

###################
# DATABASE FUNCTIONS
###################

sub init_database {
	my ($db_file) = @_;

	my $dbh = DBI->connect("dbi:SQLite:dbname=$db_file", '', '', {
		RaiseError => 1,
		AutoCommit => 1
	});

	# Create tables
	$dbh->do(qq{
		CREATE TABLE IF NOT EXISTS email_analysis (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			filename TEXT NOT NULL,
			basename TEXT NOT NULL,
			timestamp INTEGER NOT NULL,
			size INTEGER NOT NULL,
			fuzzy_hash TEXT,
			signatures_count INTEGER DEFAULT 0,
			attachments_count INTEGER DEFAULT 0,
			iocs_count INTEGER DEFAULT 0,
			vt_positives INTEGER DEFAULT 0,
			vt_total INTEGER DEFAULT 0,
			template_matches TEXT,
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP
		)
	});

	$dbh->do(qq{
		CREATE TABLE IF NOT EXISTS signatures (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			email_id INTEGER,
			hash_type TEXT NOT NULL,
			hash_value TEXT NOT NULL,
			size INTEGER NOT NULL,
			signature_name TEXT NOT NULL,
			FOREIGN KEY (email_id) REFERENCES email_analysis(id)
		)
	});

	$dbh->do(qq{
		CREATE TABLE IF NOT EXISTS iocs (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			email_id INTEGER,
			ioc_type TEXT NOT NULL,
			ioc_value TEXT NOT NULL,
			first_seen DATETIME DEFAULT CURRENT_TIMESTAMP,
			count INTEGER DEFAULT 1,
			FOREIGN KEY (email_id) REFERENCES email_analysis(id)
		)
	});

	print "Database initialized: $db_file\n" if $verbose;
	return $dbh;
}

sub store_result_in_db {
	my ($dbh, $result) = @_;

	return unless $dbh && $result;

	# Insert main record
	my $sth = $dbh->prepare(qq{
		INSERT INTO email_analysis
		(filename, basename, timestamp, size, fuzzy_hash, signatures_count,
		 attachments_count, iocs_count, vt_positives, vt_total, template_matches)
		VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
	});

	my $template_matches_json = encode_json($result->{template_matches});
	my $total_iocs = @{$result->{iocs}->{urls}} + @{$result->{iocs}->{ips}} +
					 @{$result->{iocs}->{domains}} + @{$result->{iocs}->{emails}};

	$sth->execute(
		$result->{filename},
		$result->{basename},
		$result->{timestamp},
		$result->{size},
		$result->{fuzzy_hash},
		scalar(@{$result->{signatures}}),
		scalar(@{$result->{attachments}}),
		$total_iocs,
		$result->{virustotal}->{positives} || 0,
		$result->{virustotal}->{total} || 0,
		$template_matches_json
	);

	my $email_id = $dbh->last_insert_id('', '', "email_analysis", "id");

	# Insert signatures
	foreach my $sig (@{$result->{signatures}}) {
		my $sig_sth = $dbh->prepare(qq{
			INSERT INTO signatures (email_id, hash_type, hash_value, size, signature_name)
			VALUES (?, ?, ?, ?, ?)
		});
		$sig_sth->execute($email_id, $sig->{type}, $sig->{hash}, $sig->{size}, $sig->{name});
	}

	# Insert IOCs
	foreach my $ioc_type (keys %{$result->{iocs}}) {
		foreach my $ioc_value (@{$result->{iocs}->{$ioc_type}}) {
			my $ioc_sth = $dbh->prepare(qq{
				INSERT OR IGNORE INTO iocs (email_id, ioc_type, ioc_value)
				VALUES (?, ?, ?)
			});
			$ioc_sth->execute($email_id, $ioc_type, $ioc_value);
		}
	}
}

###################
# API SERVER
###################

sub start_api_server {
	print "Starting API server on $api_host:$api_port\n";

	my $daemon = HTTP::Daemon->new(
		LocalHost => $api_host,
		LocalPort => $api_port,
		ReuseAddr => 1
	) or die "Cannot create HTTP daemon: $!";

	print "API server listening at: ", $daemon->url, "\n";

	while (my $client = $daemon->accept) {
		while (my $request = $client->get_request) {
			handle_api_request($client, $request);
		}
		$client->close;
		undef($client);
	}
}

sub handle_api_request {
	my ($client, $request) = @_;

	my $method = $request->method;
	my $path = $request->uri->path;

	if ($method eq 'POST' && $path eq '/analyze') {
		handle_analyze_request($client, $request);
	} elsif ($method eq 'GET' && $path eq '/status') {
		handle_status_request($client, $request);
	} elsif ($method eq 'GET' && $path =~ m{^/results/(.+)$}) {
		handle_results_request($client, $request, $1);
	} else {
		$client->send_error(RC_NOT_FOUND);
	}
}

sub handle_analyze_request {
	my ($client, $request) = @_;

	my $content = $request->content;
	my $temp_file = File::Temp->new(SUFFIX => '.eml', UNLINK => 0);
	print $temp_file $content;
	close($temp_file);

	# Process the uploaded EML file
	my $result = eval {
		my $temp_dir = tempdir(CLEANUP => 1);
		my $sig_fh = File::Temp->new();
		process_eml_file($temp_file->filename, $sig_fh, undef);
	};

	unlink($temp_file->filename);

	if ($@) {
		my $error_response = encode_json({ error => "Processing failed: $@" });
		$client->send_response(HTTP::Response->new(
			RC_INTERNAL_SERVER_ERROR,
			'Processing Error',
			['Content-Type' => 'application/json'],
			$error_response
		));
		return;
	}

	my $response_data = encode_json($result);
	$client->send_response(HTTP::Response->new(
		RC_OK,
		'OK',
		['Content-Type' => 'application/json'],
		$response_data
	));
}

sub handle_status_request {
	my ($client, $request) = @_;

	my $status = {
		server => 'EML Analysis API',
		version => '2.0',
		features => {
			virustotal => $HAS_VIRUSTOTAL && $virustotal_key ? 1 : 0,
			fuzzy_hashing => $HAS_SSDEEP ? 1 : 0,
			database => $database_file ? 1 : 0,
			threading => $threads > 1 ? 1 : 0
		},
		uptime => time() - $^T
	};

	my $response_data = encode_json($status);
	$client->send_response(HTTP::Response->new(
		RC_OK,
		'OK',
		['Content-Type' => 'application/json'],
		$response_data
	));
}

###################
# OUTPUT GENERATION
###################

sub generate_all_outputs {
	my ($results) = @_;

	# Generate JSON output
	if ($json_output) {
		generate_json_output($results, $json_output);
	}

	# Generate XML output
	if ($xml_output) {
		generate_xml_output($results, $xml_output);
	}

	# Generate IOC report if extraction was enabled
	if ($extract_iocs) {
		generate_ioc_report($results);
	}
}

sub generate_json_output {
	my ($results, $filename) = @_;

	my $output_data = {
		metadata => {
			generated_at => scalar(localtime()),
			generator => 'EML-to-ClamAV Advanced v2.0',
			total_files => scalar(@$results),
			statistics => \%stats
		},
		results => $results,
		global_iocs => \%global_iocs,
		signature_templates => \%templates
	};

	open(my $fh, '>', $filename) or die "Cannot open $filename: $!";
	print $fh JSON::PP->new->pretty->encode($output_data);
	close($fh);

	print "JSON report written to: $filename\n" if $verbose;
}

sub generate_xml_output {
	my ($results, $filename) = @_;

	my $output_data = {
		metadata => {
			generated_at => scalar(localtime()),
			generator => 'EML-to-ClamAV Advanced v2.0',
			total_files => scalar(@$results),
			statistics => \%stats
		},
		results => { result => $results },
		global_iocs => \%global_iocs
	};

	my $xml = XML::Simple->new();
	my $xml_content = $xml->XMLout($output_data, RootName => 'eml_analysis');

	open(my $fh, '>', $filename) or die "Cannot open $filename: $!";
	print $fh $xml_content;
	close($fh);

	print "XML report written to: $filename\n" if $verbose;
}

sub generate_ioc_report {
	my ($results) = @_;

	my $ioc_filename = $output_file;
	$ioc_filename =~ s/\.[^.]+$/_iocs.txt/;

	open(my $fh, '>', $ioc_filename) or die "Cannot open $ioc_filename: $!";

	print $fh "# IOC Report Generated: ", localtime(), "\n";
	print $fh "# Total files processed: ", scalar(@$results), "\n\n";

	# URLs
	if (keys %{$global_iocs{urls}}) {
		print $fh "# URLs (", keys(%{$global_iocs{urls}}), ")\n";
		foreach my $url (sort keys %{$global_iocs{urls}}) {
			print $fh "$url\t# Seen ", $global_iocs{urls}->{$url}, " time(s)\n";
		}
		print $fh "\n";
	}

	# IP Addresses
	if (keys %{$global_iocs{ips}}) {
		print $fh "# IP Addresses (", keys(%{$global_iocs{ips}}), ")\n";
		foreach my $ip (sort keys %{$global_iocs{ips}}) {
			print $fh "$ip\t# Seen ", $global_iocs{ips}->{$ip}, " time(s)\n";
		}
		print $fh "\n";
	}

	# Domains
	if (keys %{$global_iocs{domains}}) {
		print $fh "# Domains (", keys(%{$global_iocs{domains}}), ")\n";
		foreach my $domain (sort keys %{$global_iocs{domains}}) {
			print $fh "$domain\t# Seen ", $global_iocs{domains}->{$domain}, " time(s)\n";
		}
		print $fh "\n";
	}

	# Email Addresses
	if (keys %{$global_iocs{emails}}) {
		print $fh "# Email Addresses (", keys(%{$global_iocs{emails}}), ")\n";
		foreach my $email (sort keys %{$global_iocs{emails}}) {
			print $fh "$email\t# Seen ", $global_iocs{emails}->{$email}, " time(s)\n";
		}
		print $fh "\n";
	}

	close($fh);
	print "IOC report written to: $ioc_filename\n" if $verbose;
}

sub load_custom_templates {
	my ($template_dir) = @_;

	return unless -d $template_dir;

	opendir(my $dh, $template_dir) or return;
	my @template_files = grep { /\.json$/ } readdir($dh);
	closedir($dh);

	foreach my $file (@template_files) {
		my $filepath = "$template_dir/$file";
		open(my $fh, '<', $filepath) or next;
		local $/;
		my $content = <$fh>;
		close($fh);

		eval {
			my $template_data = decode_json($content);
			my $name = basename($file, '.json');
			$templates{$name} = $template_data;
			print "Loaded template: $name\n" if $verbose >= 2;
		};
		warn "Error loading template $file: $@" if $@;
	}
}

sub aggregate_thread_outputs {
	# Combine thread-local signature files
	open(my $main_fh, '>>', $output_file) or die "Cannot open $output_file: $!";

	for my $i (1..$threads) {
		my $thread_file = "${output_file}.thread_${i}";
		next unless -f $thread_file;

		open(my $thread_fh, '<', $thread_file) or next;
		while (my $line = <$thread_fh>) {
			print $main_fh $line;
		}
		close($thread_fh);
		unlink($thread_file);
	}
	close($main_fh);

	# Combine YARA files if enabled
	if ($yara_output) {
		open(my $main_yara_fh, '>>', $yara_output) or die "Cannot open $yara_output: $!";
		write_yara_header($main_yara_fh);

		for my $i (1..$threads) {
			my $thread_file = "${yara_output}.thread_${i}";
			next unless -f $thread_file;

			open(my $thread_fh, '<', $thread_file) or next;
			my $header_skipped = 0;
			while (my $line = <$thread_fh>) {
				# Skip header lines in thread files
				if (!$header_skipped && $line =~ /^\/\//) {
					next;
				}
				$header_skipped = 1;
				print $main_yara_fh $line;
			}
			close($thread_fh);
			unlink($thread_file);
		}
		close($main_yara_fh);
	}
}

###################
# UTILITY FUNCTIONS
###################

sub generate_signatures {
	my ($data, $name) = @_;

	my $md5 = md5_hex($data);
	my $sha1 = sha1_hex($data);
	my $sha256 = sha256_hex($data);
	my $size = length($data);

	my @sigs = (
		{
			type => 'MD5',
			hash => $md5,
			size => $size,
			name => "${sig_prefix}_${name}_MD5",
			clamav_format => "$md5:$size:${sig_prefix}_${name}_MD5"
		},
		{
			type => 'SHA1',
			hash => $sha1,
			size => $size,
			name => "${sig_prefix}_${name}_SHA1",
			clamav_format => "$sha1:$size:${sig_prefix}_${name}_SHA1"
		},
		{
			type => 'SHA256',
			hash => $sha256,
			size => $size,
			name => "${sig_prefix}_${name}_SHA256",
			clamav_format => "$sha256:$size:${sig_prefix}_${name}_SHA256"
		}
	);

	$stats{signatures_generated} += 3;
	return \@sigs;
}

sub write_signatures_to_file {
	my ($sigs, $fh) = @_;

	foreach my $sig (@$sigs) {
		print $fh $sig->{clamav_format}, "\n";
	}
}

sub write_yara_header {
	my ($fh) = @_;

	print $fh "// Auto-generated YARA rules from EML analysis\n";
	print $fh "// Generated on ", localtime(), "\n";
	print $fh "// Generator: EML-to-ClamAV Advanced v2.0\n\n";
}

sub generate_yara_email_rule {
	my ($subject, $from, $to, $basename) = @_;

	return '' unless $subject || $from;

	my $rule_name = "email_${basename}_headers";
	$rule_name =~ s/[^a-zA-Z0-9_]/_/g;

	my $rule = "rule $rule_name {\n";
	$rule .= "	meta:\n";
	$rule .= "		description = \"Email detection rule for $basename\"\n";
	$rule .= "		author = \"EML-to-ClamAV generator\"\n";
	$rule .= "		date = \"" . localtime() . "\"\n";
	$rule .= "	strings:\n";

	my $string_count = 0;
	if ($subject && length($subject) > 5) {
		$rule .= "		\$subject = \"" . escape_yara_string($subject) . "\"\n";
		$string_count++;
	}
	if ($from && length($from) > 5) {
		$rule .= "		\$from = \"" . escape_yara_string($from) . "\"\n";
		$string_count++;
	}
	if ($to && length($to) > 5) {
		$rule .= "		\$to = \"" . escape_yara_string($to) . "\"\n";
		$string_count++;
	}

	return '' unless $string_count > 0;

	$rule .= "	condition:\n";
	$rule .= "		any of them\n";
	$rule .= "}\n\n";

	return $rule;
}

sub generate_yara_executable_rule {
	my ($data, $filename, $basename) = @_;

	my $rule_name = "exe_${basename}_${filename}";
	$rule_name =~ s/[^a-zA-Z0-9_]/_/g;

	my $header = substr($data, 0, min(32, length($data)));
	my $hex_pattern = unpack('H*', $header);

	# Break hex pattern into readable chunks
	$hex_pattern =~ s/(.{2})/$1 /g;
	$hex_pattern =~ s/ $//;

	my $rule = "rule $rule_name {\n";
	$rule .= "	meta:\n";
	$rule .= "		description = \"Executable attachment from $basename\"\n";
	$rule .= "		filename = \"$filename\"\n";
	$rule .= "		author = \"EML-to-ClamAV generator\"\n";
	$rule .= "		date = \"" . localtime() . "\"\n";
	$rule .= "	strings:\n";
	$rule .= "		\$header = { $hex_pattern }\n";

	# Add additional patterns for common executable types
	if ($data =~ /^MZ/) {
		$rule .= "		\$pe_header = \"MZ\"\n";
	}
	if ($data =~ /^\x7fELF/) {
		$rule .= "		\$elf_header = { 7F 45 4C 46 }\n";
	}

	$rule .= "	condition:\n";
	$rule .= "		\$header at 0\n";
	$rule .= "}\n\n";

	return $rule;
}

sub is_text_part {
	my ($part) = @_;
	my $type = $part->effective_type;
	return $type =~ /^(text\/|multipart\/)/;
}

sub decode_header {
	my ($header) = @_;
	return '' unless defined $header;

	# Basic MIME header decoding
	eval {
		if ($header =~ /=\?[^?]+\?[BQ]\?[^?]+\?=/) {
			# This is simplified - in production, use MIME::Words
			$header =~ s/=\?[^?]+\?[BQ]\?([^?]+)\?=/$1/gi;
		}
	};

	return $header;
}

sub get_email_body {
	my ($entity) = @_;

	my @parts = $entity->parts_DFS;
	foreach my $part (@parts) {
		if ($part->effective_type eq 'text/plain') {
			my $body = $part->bodyhandle;
			return $body ? $body->as_string : '';
		}
	}
	return '';
}

sub get_full_email_content {
	my ($entity) = @_;

	my $content = '';

	# Get headers
	my $head = $entity->head;
	$content .= $head->as_string . "\n";

	# Get body content
	my @parts = $entity->parts_DFS;
	foreach my $part (@parts) {
		if ($part->effective_type =~ /^text\//) {
			my $body = $part->bodyhandle;
			$content .= $body->as_string . "\n" if $body;
		}
	}

	return $content;
}

sub extract_attachment_data {
	my ($part) = @_;

	my $body = $part->bodyhandle;
	return unless $body;

	my $data;
	if ($body->path) {
		open(my $fh, '<:raw', $body->path) or return;
		local $/;
		$data = <$fh>;
		close($fh);
	} else {
		$data = $body->as_string;
	}

	return $data;
}

sub is_executable {
	my ($data, $filename) = @_;

	# Check file extension
	return 1 if $filename =~ /\.(exe|dll|scr|bat|cmd|com|pif|vbs|js|jar|msi)$/i;

	# Check magic bytes
	return 1 if $data =~ /^MZ/;  # PE executable
	return 1 if $data =~ /^\x7fELF/;  # ELF executable
	return 1 if $data =~ /^PK\x03\x04.*\.exe/s;  # ZIP with exe
	return 1 if $data =~ /^\x50\x4b\x03\x04/;  # ZIP file (potential dropper)

	return 0;
}

sub get_attachment_filename {
	my ($part) = @_;

	my $filename = $part->head->recommended_filename;

	if (!$filename) {
		my $disp = $part->head->get('Content-Disposition', 0);
		if ($disp && $disp =~ /filename[*]?=(?:"([^"]+)"|([^;\s]+))/i) {
			$filename = $1 || $2;
		}
	}

	if (!$filename) {
		my $type = $part->head->get('Content-Type', 0);
		if ($type && $type =~ /name[*]?=(?:"([^"]+)"|([^;\s]+))/i) {
			$filename = $1 || $2;
		}
	}

	$filename = decode_header($filename) if $filename;
	$filename ||= $part->effective_type;
	$filename =~ s/\//_/g;

	return $filename;
}

sub is_valid_ip {
	my ($ip) = @_;
	my @octets = split(/\./, $ip);
	return 0 unless @octets == 4;

	foreach my $octet (@octets) {
		return 0 if $octet < 0 || $octet > 255;
		return 0 if $octet =~ /^0\d/; # No leading zeros
	}

	# Skip private/reserved ranges for IOC purposes
	return 0 if $ip =~ /^(10\.|192\.168\.|172\.(1[6-9]|2[0-9]|3[01])\.|127\.|0\.)/;

	return 1;
}

sub escape_yara_string {
	my ($str) = @_;
	$str =~ s/\\/\\\\/g;
	$str =~ s/"/\\"/g;
	$str =~ s/\n/\\n/g;
	$str =~ s/\r/\\r/g;
	$str =~ s/\t/\\t/g;
	return substr($str, 0, 100); # Limit length for YARA
}

sub min {
	return $_[0] < $_[1] ? $_[0] : $_[1];
}

sub create_error_result {
	my ($filename, $error) = @_;

	return {
		filename => $filename,
		basename => basename($filename, '.eml'),
		timestamp => time(),
		size => -s $filename || 0,
		error => $error,
		signatures => [],
		attachments => [],
		iocs => { urls => [], ips => [], domains => [], emails => [] },
		template_matches => [],
		yara_rules => []
	};
}

sub print_final_stats {
	my $duration = time() - $stats{start_time};

	print "\n", "="x70, "\n";
	print "PROCESSING COMPLETE - ADVANCED EML ANALYZER v2.0\n";
	print "="x70, "\n";
	printf "Files processed:	   %d\n", $stats{files_processed};
	printf "Files failed:		  %d\n", $stats{files_failed};
	printf "Signatures generated:  %d\n", $stats{signatures_generated};
	printf "Attachments processed: %d\n", $stats{attachments_processed};
	printf "Duplicates skipped:	%d\n", $stats{duplicates_skipped} if $duplicate_check;
	printf "IOCs extracted:		%d\n", $stats{iocs_extracted} if $extract_iocs;
	printf "VirusTotal queries:	%d\n", $stats{vt_queries} if $vt_client;
	printf "Processing time:	   %.2f seconds\n", $duration;
	printf "Files per second:	  %.1f\n", $stats{files_processed} / $duration if $duration > 0;

	print "\nOutput files generated:\n";
	print "  ClamAV signatures:   $output_file\n";
	print "  YARA rules:		  $yara_output\n" if $yara_output;
	print "  JSON report:		 $json_output\n" if $json_output;
	print "  XML report:		  $xml_output\n" if $xml_output;
	print "  Database:			$database_file\n" if $database_file;

	if ($extract_iocs && %global_iocs) {
		print "\nIOC Summary:\n";
		printf "  URLs:				%d unique\n", scalar(keys %{$global_iocs{urls}});
		printf "  IP addresses:		%d unique\n", scalar(keys %{$global_iocs{ips}});
		printf "  Domains:			 %d unique\n", scalar(keys %{$global_iocs{domains}});
		printf "  Email addresses:	 %d unique\n", scalar(keys %{$global_iocs{emails}});
	}

	print "\n", "="x70, "\n";
}

__END__

=head1 NAME

eml_to_clamav.pl - EML to ClamAV signature generator

=head1 SYNOPSIS

eml_to_clamav.pl [options] <files_or_directories>

 Basic Options:
   -o, --output		 Output signature file (default: signatures.hdb)
   -p, --prefix		 Signature name prefix (default: EMAIL_MALWARE)
   -v, --verbose		Verbose output (use -vv for more detail)
   -r, --recursive	  Process directories recursively
   -j, --threads		Number of processing threads (default: 1)
   -h, --help		   Show this help message

 Advanced Options:
   --min-size		   Minimum file size in bytes (default: 10)
   --max-size		   Maximum file size in bytes (default: 52428800)
   --no-duplicate-check Disable duplicate detection
   --include-body	   Include email body in signatures

 Output Formats:
   --yara			   Generate YARA rules file
   --json			   Generate JSON report file
   --xml				Generate XML report file

 Analysis Features:
   --extract-iocs	   Extract indicators of compromise
   --fuzzy-hash		 Generate fuzzy (ssdeep) hashes
   --templates		  Custom template directory for malware classification
   --virustotal-key	 VirusTotal API key for malware checking

 Database & API:
   --database		   SQLite database file for storing results
   --api-port		   Start REST API server on specified port
   --api-host		   API server host (default: localhost)

=head1 DESCRIPTION

Enterprise-grade EML file processor with advanced malware analysis capabilities:

- Multi-threaded processing for high-volume analysis
- VirusTotal integration for known malware detection
- Custom signature templates for malware family classification
- IOC extraction (URLs, IPs, domains, emails)
- Fuzzy hashing for similarity detection
- Database storage for large-scale operations
- REST API for automated integration
- Multiple output formats (ClamAV, YARA, JSON, XML)

=head1 EXAMPLES

 # Basic batch processing with threading
 perl eml_to_clamav.pl -j 4 -r -v /malware/emails/

 # Full
 perl eml_to_clamav.pl --threads 8 --extract-iocs --fuzzy-hash \
   --yara rules.yar --json report.json --database analysis.db \
   --virustotal-key YOUR_API_KEY --templates ./templates/ \
   /samples/

 # Start API server
 perl eml_to_clamav.pl --api-port 8080 --database analysis.db

 # or
 perl eml_to_clamav.pl --api-port 8080 --database analysis.db \
  --virustotal-key YOUR_KEY --templates ./templates/

 # Large-scale processing with all features
 perl eml_to_clamav.pl -j 16 -r -vv --extract-iocs --fuzzy-hash \
   --yara malware.yar --json results.json --xml results.xml \
   --database malware.db --templates ./custom_templates/ \
   --virustotal-key API_KEY --min-size 1000 --max-size 10000000 \
   /massive_email_corpus/

=head1 API ENDPOINTS

When running in API mode:

 POST /analyze		  - Analyze uploaded EML file
 GET  /status		   - Server status and capabilities
 GET  /results/{id}	 - Retrieve analysis results

=head1 REQUIREMENTS

Analyze file via API:
curl -X POST -H "Content-Type: application/octet-stream" \
     --data-binary @malware.eml http://localhost:8080/analyze

Check server status:
curl http://localhost:8080/status

Core modules:
 MIME::tools, Digest::MD5, Digest::SHA, Time::HiRes, Encode,
 JSON::PP, XML::Simple, File::Find, DBI, threads, HTTP::Daemon

Optional modules:
 Digest::ssdeep		 - For fuzzy hashing
 WebService::VirusTotal - For VirusTotal integration
 DBD::SQLite		   - For database functionality

Install with:
 cpan MIME::tools JSON::PP XML::Simple DBI DBD::SQLite threads \
	  HTTP::Daemon Digest::ssdeep WebService::VirusTotal

=head1 TEMPLATE FORMAT

Custom templates are JSON files defining malware patterns:

 {
   "patterns": ["bank", "account", "verify", "suspended"],
   "weight": 0.8,
   "category": "banking_trojan",
   "severity": "high"
 }

=head1 DATABASE SCHEMA

The SQLite database contains:
 - email_analysis: Main analysis results
 - signatures: Generated hash signatures
 - iocs: Extracted indicators of compromise

=head1 PERFORMANCE

Optimized for high-volume processing:
 - Multi-threaded analysis (up to CPU cores)
 - Duplicate detection and skipping
 - Memory-efficient streaming for large files
 - Batch database operations
 - Configurable size limits

=head1 SECURITY

Security considerations:
 - Sandboxed parsing of untrusted content
 - Size limits to prevent resource exhaustion
 - Input validation and sanitization
 - Safe handling of executable attachments

=head1 SUPPORT

This module is provided as-is without any warranty.

=head1 AUTHOR

Nigel Horne, C<< <njh at nigelhorne.com> >>

=cut
