#!/usr/bin/env perl
#
use strict;
use warnings;

use MIME::Parser;
use Digest::MD5 qw(md5_hex);
use Digest::SHA qw(sha1_hex sha256_hex);
use File::Temp qw(tempdir);
use File::Basename;
use File::Find;
use Getopt::Long;
use Pod::Usage;
use Time::HiRes qw(time);
use Encode qw(decode);

# Global variables
my $output_file = 'signatures.hdb';
my $sig_prefix = 'NJH';
my $help = 0;
my $verbose = 0;
my $recursive = 0;
my $min_size = 10;  # Minimum file size for signatures
my $max_size = 50 * 1024 * 1024;  # 50MB max file size
my $duplicate_check = 1;
my $yara_output = '';
my $include_body = 0;
my $threads = 1;

# Parse command line options
GetOptions(
	'output|o=s'		=> \$output_file,
	'prefix|p=s'		=> \$sig_prefix,
	'verbose|v+'		=> \$verbose,
	'recursive|r'	   => \$recursive,
	'min-size=i'		=> \$min_size,
	'max-size=i'		=> \$max_size,
	'no-duplicate-check' => sub { $duplicate_check = 0 },
	'yara=s'			=> \$yara_output,
	'include-body'	  => \$include_body,
	'threads|j=i'	   => \$threads,
	'help|h'			=> \$help,
) or pod2usage(2);

pod2usage(1) if $help;
pod2usage("Error: No EML files specified") if @ARGV == 0;

my @input_paths = @ARGV;
my @eml_files;

# Collect EML files (with recursive option)
foreach my $path (@input_paths) {
	if (-f $path) {
		push @eml_files, $path;
	} elsif (-d $path && $recursive) {
		find(sub {
			push @eml_files, $File::Find::name if /\.eml$/i && -f;
		}, $path);
	} elsif (-d $path) {
		warn "Skipping directory '$path' (use -r for recursive)\n";
	} else {
		warn "Path '$path' does not exist\n";
	}
}

die "Error: No EML files found" unless @eml_files;

print "Found ", scalar(@eml_files), " EML file(s)\n" if $verbose;

# Filter by size
my @valid_files;
foreach my $file (@eml_files) {
	my $size = -s $file;
	if ($size < $min_size) {
		print "Skipping $file (too small: $size bytes)\n" if $verbose >= 2;
		next;
	}
	if ($size > $max_size) {
		print "Skipping $file (too large: $size bytes)\n" if $verbose >= 2;
		next;
	}
	push @valid_files, $file;
}

@eml_files = @valid_files;
print "Processing " . scalar(@eml_files) . " valid EML file(s)\n" if $verbose;

# Hash tracking for duplicates
my %seen_hashes if $duplicate_check;

# Statistics
my %stats = (
	files_processed => 0,
	files_failed => 0,
	signatures_generated => 0,
	attachments_processed => 0,
	duplicates_skipped => 0,
	start_time => time(),
);

# Open output files
open(my $sig_fh, '>>', $output_file) or die "Cannot open $output_file: $!";
print "Writing signatures to: $output_file\n" if $verbose;

my $yara_fh;
if ($yara_output) {
	open($yara_fh, '>>', $yara_output) or die "Cannot open $yara_output: $!";
	print "Writing YARA rules to: $yara_output\n" if $verbose;
	print $yara_fh "// Auto-generated YARA rules from EML analysis\n";
	print $yara_fh "// Generated on " . localtime() . "\n\n";
}

# Process each EML file
my $file_count = 0;
foreach my $eml_file (@eml_files) {
	$file_count++;
	print "\n" . "="x60 . "\n" if $verbose;
	print "[$file_count/" . scalar(@eml_files) . "] Processing: " . basename($eml_file) . "\n" if $verbose;

	eval {
		process_eml_file($eml_file, $sig_fh, $yara_fh);
		$stats{files_processed}++;
	};
	if ($@) {
		warn "Error processing '$eml_file': $@\n";
		$stats{files_failed}++;
	}

	# Progress indicator for large batches
	if ($file_count % 100 == 0 && !$verbose) {
		print "Processed $file_count/" . scalar(@eml_files) . " files...\n";
	}
}

close($sig_fh);
close($yara_fh) if $yara_fh;

# Print final statistics
print_final_stats();

sub process_eml_file {
	my ($eml_file, $sig_fh, $yara_fh) = @_;

	# Create temporary directory for parsing this file
	my $temp_dir = tempdir(CLEANUP => 1);
	print "Using temporary directory: $temp_dir\n" if $verbose >= 2;

	# Initialize MIME parser with better error handling
	my $parser = MIME::Parser->new();
	$parser->output_dir($temp_dir);
	$parser->extract_nested_messages(1);
	$parser->extract_uuencode(1);
	$parser->decode_headers(1);
	$parser->filer->ignore_filename(1);  # Avoid filename conflicts

	# Parse the EML file
	my $entity = $parser->parse_open($eml_file);

	my $file_basename = basename($eml_file, '.eml');
	$file_basename =~ s/[^a-zA-Z0-9._-]/_/g;  # Sanitize filename

	# Generate signature for the main email
	generate_email_signature($entity, $sig_fh, $yara_fh, $file_basename, $eml_file);

	# Process attachments with better filtering
	my @parts = $entity->parts_DFS;
	my $attachment_count = 0;

	foreach my $part (@parts) {
		next if is_text_part($part);

		my $filename = get_attachment_filename($part);
		print "  Processing attachment: $filename\n" if $verbose;

		if (generate_attachment_signature($part, $filename, $attachment_count, $sig_fh, $yara_fh, $file_basename)) {
			$attachment_count++;
			$stats{attachments_processed}++;
		}
	}

	print "  Found $attachment_count attachment(s)\n" if $verbose;

	# Clean up
	$entity->purge;
}

sub generate_email_signature {
	my ($entity, $sig_fh, $yara_fh, $file_basename, $eml_path) = @_;

	# Get email headers with better encoding handling
	my $head = $entity->head;
	my $subject = decode_header($head->get('Subject', 0) || '');
	my $from = decode_header($head->get('From', 0) || '');
	my $to = decode_header($head->get('To', 0) || '');
	my $message_id = $head->get('Message-ID', 0) || '';

	chomp($subject, $from, $to, $message_id);

	# Create signature data
	my $sig_data = "Subject: $subject\nFrom: $from\nTo: $to\nMessage-ID: $message_id";

	# Include email body if requested
	if ($include_body) {
		my $body = get_email_body($entity);
		$sig_data .= "\nBody: " . substr($body, 0, 1000) if $body;  # First 1KB only
	}

	# Generate and write signatures
	write_signatures($sig_data, "${file_basename}_EMAIL_HEADERS", $sig_fh);

	# Generate YARA rule if requested
	if ($yara_fh) {
		generate_yara_rule($subject, $from, $to, $file_basename, $yara_fh, "email_headers");
	}

	if ($verbose >= 2) {
		print "  Email headers signature generated\n";
		print "	Subject: " . substr($subject, 0, 50) . "...\n" if length($subject) > 50;
		print "	From: $from\n";
	}
}

sub generate_attachment_signature {
	my ($part, $filename, $index, $sig_fh, $yara_fh, $file_basename) = @_;

	# Get attachment data with better error handling
	my $data = extract_attachment_data($part);
	return 0 unless defined $data && length($data) >= $min_size;

	# Skip if too large
	return 0 if length($data) > $max_size;

	# Check for duplicates
	if ($duplicate_check) {
		my $quick_hash = md5_hex(substr($data, 0, 1024));  # Quick hash of first 1KB
		if ($seen_hashes{$quick_hash}) {
			print "	Skipping duplicate attachment\n" if $verbose >= 2;
			$stats{duplicates_skipped}++;
			return 0;
		}
		$seen_hashes{$quick_hash} = 1;
	}

	# Clean filename for signature name
	$filename =~ s/[^a-zA-Z0-9._-]/_/g;
	$filename = "ATTACHMENT_${index}" if !$filename || $filename eq '';

	# Generate and write signatures
	write_signatures($data, "${file_basename}_${filename}", $sig_fh);

	# Generate YARA rule for executable attachments
	if ($yara_fh && is_executable($data, $filename)) {
		generate_yara_executable_rule($data, $filename, $file_basename, $yara_fh);
	}

	if ($verbose >= 2) {
		print "	Attachment '$filename': " . length($data) . " bytes\n";
	}

	return 1;
}

sub write_signatures {
	my ($data, $name, $fh) = @_;

	# Generate hashes
	my $md5 = md5_hex($data);
	my $sha1 = sha1_hex($data);
	my $sha256 = sha256_hex($data);
	my $size = length($data);

	# Write signatures in ClamAV format
	print $fh "$md5:$size:${sig_prefix}_${name}_MD5\n";
	print $fh "$sha1:$size:${sig_prefix}_${name}_SHA1\n";
	print $fh "$sha256:$size:${sig_prefix}_${name}_SHA256\n";

	$stats{signatures_generated} += 3;
}

sub generate_yara_rule {
	my ($subject, $from, $to, $basename, $fh, $type) = @_;

	return unless $subject || $from;

	my $rule_name = "email_${basename}_${type}";
	$rule_name =~ s/[^a-zA-Z0-9_]/_/g;

	print $fh "rule $rule_name {\n";
	print $fh "	meta:\n";
	print $fh "		description = \"Email detection rule for $basename\"\n";
	print $fh "		author = \"EML-to-ClamAV generator\"\n";
	print $fh "		date = \"" . localtime() . "\"\n";
	print $fh "	strings:\n";

	my $string_count = 0;
	if ($subject && length($subject) > 5) {
		print $fh "		\$subject = \"" . escape_yara_string($subject) . "\"\n";
		$string_count++;
	}
	if ($from && length($from) > 5) {
		print $fh "		\$from = \"" . escape_yara_string($from) . "\"\n";
		$string_count++;
	}

	print $fh "	condition:\n";
	print $fh "		any of them\n" if $string_count > 1;
	print $fh "		\$subject\n" if $string_count == 1 && $subject;
	print $fh "		\$from\n" if $string_count == 1 && !$subject && $from;
	print $fh "}\n\n";
}

sub generate_yara_executable_rule {
	my ($data, $filename, $basename, $fh) = @_;

	my $rule_name = "exe_${basename}_${filename}";
	$rule_name =~ s/[^a-zA-Z0-9_]/_/g;

	# Extract some bytes for pattern matching
	my $header = substr($data, 0, min(32, length($data)));
	my $hex_pattern = unpack("H*", $header);

	print $fh "rule $rule_name {\n";
	print $fh "	meta:\n";
	print $fh "		description = \"Executable attachment from $basename\"\n";
	print $fh "		filename = \"$filename\"\n";
	print $fh "	strings:\n";
	print $fh "		\$header = { $hex_pattern }\n";
	print $fh "	condition:\n";
	print $fh "		\$header at 0\n";
	print $fh "}\n\n";
}

# Utility functions
sub is_text_part {
	my ($part) = @_;
	my $type = $part->effective_type;
	return $type =~ /^(text\/|multipart\/)/;
}

sub decode_header {
	my ($header) = @_;
	return '' unless defined $header;

	# Try to decode MIME encoded headers
	eval {
		if ($header =~ /=\?[^?]+\?[BQ]\?[^?]+\?=/) {
			# This is a simplified decoder - in production use MIME::Words
			$header =~ s/=\?[^?]+\?[BQ]\?([^?]+)\?=/$1/gi;
		}
	};

	return $header;
}

sub get_email_body {
	my ($entity) = @_;

	my @parts = $entity->parts_DFS;
	foreach my $part (@parts) {
		if ($part->effective_type eq 'text/plain') {
			my $body = $part->bodyhandle;
			return $body ? $body->as_string : '';
		}
	}
	return '';
}

sub extract_attachment_data {
	my ($part) = @_;

	my $body = $part->bodyhandle;
	return unless $body;

	my $data;
	if ($body->path) {
		open(my $fh, '<:raw', $body->path) or return;
		local $/;
		$data = <$fh>;
		close($fh);
	} else {
		$data = $body->as_string;
	}

	return $data;
}

sub is_executable {
	my ($data, $filename) = @_;

	# Check file extension
	return 1 if $filename =~ /\.(exe|dll|scr|bat|cmd|com|pif|vbs|js|jar)$/i;

	# Check magic bytes
	return 1 if $data =~ /^MZ/;  # PE executable
	return 1 if $data =~ /^\x7fELF/;  # ELF executable
	return 1 if $data =~ /^PK\x03\x04.*\.exe/s;  # ZIP with exe

	return 0;
}

sub get_attachment_filename {
	my ($part) = @_;

	# Try multiple methods to get filename
	my $filename = $part->head->recommended_filename;

	if (!$filename) {
		my $disp = $part->head->get('Content-Disposition', 0);
		if ($disp && $disp =~ /filename[*]?=(?:"([^"]+)"|([^;\s]+))/i) {
			$filename = $1 || $2;
		}
	}

	if (!$filename) {
		my $type = $part->head->get('Content-Type', 0);
		if ($type && $type =~ /name[*]?=(?:"([^"]+)"|([^;\s]+))/i) {
			$filename = $1 || $2;
		}
	}

	# Decode if needed and clean
	$filename = decode_header($filename) if $filename;
	$filename ||= $part->effective_type;
	$filename =~ s/\//_/g;

	return $filename;
}

sub escape_yara_string {
	my ($str) = @_;
	$str =~ s/\\/\\\\/g;
	$str =~ s/"/\\"/g;
	return $str;
}

sub min {
	return $_[0] < $_[1] ? $_[0] : $_[1];
}

sub print_final_stats {
	my $duration = time() - $stats{start_time};

	print "\n" . "="x60 . "\n";
	print "PROCESSING COMPLETE\n";
	print "="x60 . "\n";
	print "Files processed:	  $stats{files_processed}\n";
	print "Files failed:		 $stats{files_failed}\n";
	print "Signatures generated: $stats{signatures_generated}\n";
	print "Attachments processed: $stats{attachments_processed}\n";
	print "Duplicates skipped:   $stats{duplicates_skipped}\n" if $duplicate_check;
	printf "Processing time:	  %.2f seconds\n", $duration;
	print "Signatures per second: " . sprintf("%.1f", $stats{signatures_generated} / $duration) . "\n" if $duration > 0;
	print "\nOutput files:\n";
	print "  ClamAV signatures: $output_file\n";
	print "  YARA rules: $yara_output\n" if $yara_output;
}

__END__

=head1 NAME

eml_to_clamav.pl - Advanced EML to ClamAV signature generator

=head1 SYNOPSIS

eml_to_clamav.pl [options] <files_or_directories>

 Options:
   -o, --output		 Output signature file (default: signatures.hdb)
   -p, --prefix		 Signature name prefix (default: EMAIL_MALWARE)
   -v, --verbose		Verbose output (use -vv for more detail)
   -r, --recursive	  Process directories recursively
   --min-size		   Minimum file size in bytes (default: 10)
   --max-size		   Maximum file size in bytes (default: 52428800)
   --no-duplicate-check Disable duplicate detection
   --yara			   Generate YARA rules file
   --include-body	   Include email body in signatures
   -j, --threads		Number of threads (future use)
   -h, --help		   Show this help message

=head1 DESCRIPTION

Advanced EML file processor that generates ClamAV signatures and optionally
YARA rules. Supports batch processing, recursive directory scanning,
duplicate detection, and various optimization features.

=head1 EXAMPLES

 # Process single file
 perl eml_to_clamav.pl malware.eml

 # Process directory recursively with YARA output
 perl eml_to_clamav.pl -r -v --yara rules.yar /path/to/emails/

 # Batch process with size limits
 perl eml_to_clamav.pl --min-size 100 --max-size 10000000 *.eml

 # Include email body in signatures
 perl eml_to_clamav.pl --include-body suspicious.eml

=head1 REQUIREMENTS

MIME::tools, Digest::MD5, Digest::SHA, Time::HiRes, Encode

=head1 AUTHOR

Nigel Horne, C<< <njh at nigelhorne.com> >>

=head1 SUPPORT

This module is provided as-is without any warranty.

=cut
